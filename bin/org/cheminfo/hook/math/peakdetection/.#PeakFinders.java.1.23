package org.cheminfo.hook.math.peakdetection;

import java.awt.Point;
import java.io.FileNotFoundException;
import java.io.PrintStream;
import java.util.Arrays;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.Vector;

import org.cheminfo.hook.math.fft.Convolution;
import org.cheminfo.hook.math.fft.filters.SavitzkyGolay;
import org.cheminfo.hook.math.util.MathUtils;
import org.cheminfo.hook.nemo.SpectraData;
import org.cheminfo.hook.nemo.nmr.IntegralData;
import org.cheminfo.hook.nemo.nmr.Nucleus;
import org.cheminfo.hook.nemo.signal.NMRSignal1D;

public class PeakFinders {
	private static boolean DEBUG = false;
	/**
	 * 
	 * Peak detection based on the criteria from
	 * 
	 * automatic program for peak detection and deconvolution of
	 * multi-overlapped chromatographic signals Part I: Peak detection Journal
	 * of Chromatography A
	 * 
	 * DOI: http://dx.doi.org/10.1016/j.chroma.2005.03.072
	 * 
	 * Quoting informally from said publication:
	 * 
	 * The algorithm is based on identifying negative regions in the second
	 * derivative. Some local thresholding is applied (see ref). Here the
	 * routine is extend to include a global threshhold
	 * 
	 * 
	 * @param data
	 * @param negative
	 * @return
	 */
	public static int[] simpleFindJChromA(double[] data, boolean negative,
			double threshold) {
		double sign = negative ? -1.0 : 1.0;
		threshold *= sign;
		LinkedList<Integer> indeces = new LinkedList<Integer>();
		boolean abort = false;
		for (int i = 0; i < data.length; i++) {
			if (sign * data[i] > threshold) {
				if (i == data.length - 1)
					break;
				// identify a positive region!
				int start = i;
				while (sign * data[++i] > threshold) {
					if (i == data.length - 1) {
						abort = true;
						break;
					}
				}
				if (abort)
					break;
				int end = i;
				int nPoints = end - start + 1;
				// evaluate negative region
				if (nPoints >= 5) {
					double[] hValues = new double[nPoints - 2];
					/*
					 * local thresholding. Compute values h_i which are the
					 * distance of the second derivative p_i from the mean of
					 * its neighbours p_{i-1} and p_{i+1}
					 * 
					 * The noise is taken as the median of the h_i values. Thus
					 * the criteria nPoints >= 5
					 */
					for (int j = 1; j < nPoints - 1; j++) {

						double diff = data[start + j] - 0.5
								* (data[start + j + 1] + data[start + j - 1]);
						diff = Math.abs(diff);
						hValues[j - 1] = diff;
					}
					Arrays.sort(hValues);
					double noise = hValues[hValues.length / 2]; // the median of
					// the hi m
					double max = Double.MIN_VALUE;
					int maxIndex = -1;
					for (int j = start; j <= end; j++) {
						if (sign * data[j] > 1 * noise && sign * data[j] > max) {
							max = sign * data[j];
							maxIndex = j;
						}
					}
					if (maxIndex != -1) {
						indeces.add(new Integer(maxIndex));
					}
				}
			}
		}
		int[] peakIndeces = null;
		if (indeces.size() > 0) {
			peakIndeces = new int[indeces.size()];
			int i = 0;
			Iterator<Integer> iterator = indeces.iterator();
			while (iterator.hasNext()) {
				peakIndeces[i++] = iterator.next().intValue();
			}
		}
		return peakIndeces;
	}

	public static int[] simpleFindJChromAVariant(double[] yData,
			double[] secondDerivative, double threshold) {
		LinkedList<Integer> indeces = new LinkedList<Integer>();
		boolean abort = false;
		for (int i = 0; i < secondDerivative.length; i++) {
			if (secondDerivative[i] < 0) {
				if (i == secondDerivative.length - 1)
					break;
				// identify a positive region!
				int start = i;
				while (secondDerivative[++i] < 0) {
					if (i == secondDerivative.length - 1) {
						abort = true;
						break;
					}
				}
				if (abort)
					break;
				int end = i;
				int nPoints = end - start + 1;
				// evaluate negative region
				if (nPoints >= 5) {
					/*
					 * local thresholding. Compute values h_i which are the
					 * distance of the second derivative p_i from the mean of
					 * its neighbours p_{i-1} and p_{i+1}
					 * 
					 * The noise is taken as the median of the h_i values. Thus
					 * the criteria nPoints >= 5
					 */
					double[] hSecondDer = new double[nPoints - 2];
					double meanSecondDer = 0.0;
					double stddevSecondDer = 0.0;
					double meanData = 0.0;
					double stddevData = 0.0;
					for (int j = 0; j < nPoints; j++) {
						meanSecondDer += secondDerivative[start + j];
						stddevSecondDer += secondDerivative[start + j]
								* secondDerivative[start + j];
						meanData += yData[start + j];
						stddevData += yData[start + j] * yData[start + j];
					}
					meanSecondDer /= nPoints;
					stddevSecondDer /= nPoints;
					stddevSecondDer = Math.sqrt(stddevSecondDer - meanSecondDer
							* meanSecondDer);
					meanData /= nPoints;
					stddevData /= nPoints;
					stddevData = Math.sqrt(stddevData - meanData * meanData);

					double[] hData = new double[nPoints - 2];
					for (int j = 1; j < nPoints - 1; j++) {
						hData[j - 1] = Math
								.abs(yData[start + j]
										- 0.5
										* (yData[start + j + 1] + yData[start
												+ j - 1]));
						hSecondDer[j - 1] = Math
								.abs(secondDerivative[start + j]
										- 0.5
										* (secondDerivative[start + j + 1] + secondDerivative[start
												+ j - 1]));
					}
					Arrays.sort(hSecondDer);
					Arrays.sort(hData);
					// double dataNoise = hData[hData.length / 2];
					// double secondDerNoise = hSecondDer[hSecondDer.length /
					// 2];
					double max = Double.MIN_VALUE;
					int maxIndex = -1;
					for (int j = start; j <= end; j++) {
						// yData[j] > max && yData[j] >= (meanData + stddevData)
						// &&
						if (yData[j] > max && yData[j] > threshold
						// && Math.abs(secondDerivative[j]) >
						// Math.abs(meanSecondDer) + 1.0 * stddevSecondDer
						) {
							max = yData[j];
							maxIndex = j;
						}
					}
					if (maxIndex != -1) {
						indeces.add(new Integer(maxIndex));
					}
				}
			}
		}
		int[] peakIndeces = null;
		if (indeces.size() > 0) {
			peakIndeces = new int[indeces.size()];
			int i = 0;
			Iterator<Integer> iterator = indeces.iterator();
			while (iterator.hasNext()) {
				peakIndeces[i++] = iterator.next().intValue();
			}
		}
		return peakIndeces;
	}

	public static int[] sillyFind(double[] data, int width) {
		int[] result = null;
		LinkedList<Integer> list = new LinkedList<Integer>();
		boolean isMax;
		int j;
		for (int i = width; i < data.length - width; i++) {
			isMax = true;
			for (j = 1; j <= width && isMax; j++) {
				isMax = (data[i + j] < data[i + j - 1]) && (data[i - j] < data[i - j + 1]) ? true : false;
			}
			if (isMax) {
				list.add(new Integer(i));
			}
		}
		if (!list.isEmpty()) {
			result = new int[list.size()];
			Iterator<Integer> iterator = list.iterator();
			j = 0;
			Integer value;
			while (iterator.hasNext()) {
				value = iterator.next();
				result[j++] = value.intValue();
			}
		}
		return result;
	}

	/**
	 * This method implements the peak identification approach as proposed by
	 * Dietrich et al. in J. Magn. Reson. 91 (1991) 1-11
	 * 
	 * The method is based on constructing a pseudo power spectrum of the data
	 * series which is the square of the first derivative. In this
	 * implementation the data is assumed to already have the correct form e.g.
	 * being a first derivative. Note: the method might also be suitable for
	 * series that do not come as first derivatives.
	 * 
	 * The algorithm proceeds as follows. 1. Init a bitmask for the data series
	 * with all values equal to true 2. From the data series calculate the mean
	 * and standard deviation for all points which have a true value in the
	 * bitmask 3. Eliminate all points that are below the mean plus 3 times the
	 * standard deviation 3. go back to step 2. until the bitmask is no long
	 * changed
	 * 
	 * @param data
	 * @return
	 */
	public static int[] dietrichFind(double[] data) {
		int[] bitmask = dietrichBitmask(data);
		LinkedList<Point> ranges = new LinkedList<Point>();
		for (int i = 0; i < bitmask.length; i++) {
			if (bitmask[i] == 0) {
				Point range = new Point();
				range.x = i;
				while (i < bitmask.length - 1 && bitmask[++i] == 0) {
				}
				range.y = i - 1;
				ranges.add(range);
			}
		}
		int[] result = null;
		if (ranges.size() > 0) {
			result = new int[ranges.size() * 2];
			Iterator<Point> iterator = ranges.iterator();
			int i = 0;
			while (iterator.hasNext()) {
				Point range = iterator.next();
				result[i++] = range.x;
				result[i++] = range.y;
			}
		}
		return result;
	}

	public static int[] dietrichBitmask(double[] data) {
		double[] powerSpectrum = data;
		// bitmask: 1=baseline, 0=peak
		int[] bitmask = new int[powerSpectrum.length];
		for (int i = 0; i < powerSpectrum.length; i++) {
			powerSpectrum[i] = powerSpectrum[i] * powerSpectrum[i];
			bitmask[i] = 1;
		}
		boolean foundNewPoints = true;
		int nFound = 0;
		while (foundNewPoints) {
			// Calculate
			double mean = 0.0;
			double variance = 0.0;
			nFound = 0;
			for (int i = 0; i < powerSpectrum.length; i++) {
				mean += bitmask[i] * powerSpectrum[i];
				variance += bitmask[i] * powerSpectrum[i] * powerSpectrum[i];
				nFound += bitmask[i];
			}
			mean /= nFound;
			variance /= nFound;
			variance -= mean * mean;
			double threshold = mean + 3 * (Math.sqrt(variance));
			foundNewPoints = false;
			int[] savedBitmask = bitmask.clone();
			for (int i = 0; i < powerSpectrum.length; i++) {
				if ((powerSpectrum[i] * bitmask[i]) > threshold) {
					bitmask[i] = 0;
					foundNewPoints = true;
				}
			}
			if (foundNewPoints == false)
				bitmask = savedBitmask;
		}
		// remove spikes
		for (int i = 1; i < bitmask.length - 1; i++) {
			if (bitmask[i] == 1 && bitmask[i - 1] == 0 && bitmask[i + 1] == 0) {
				// both neighbours are in the peak set
				bitmask[i] = 0;
			} else if (bitmask[i] == 0 && bitmask[i - 1] == 1
					&& bitmask[i + 1] == 1) {
				// both neighbours are in the baseline set
				bitmask[i] = 1;
			}
		}
		return bitmask;
	}

	/**
	 * 
	 * dietrichFind but calculate derivatives with Haar Wavelets
	 * 
	 * @param data
	 * @param scale
	 * @return
	 */
	public static int[] waveletDietrichFind(double[] data, int scale) {
		return dietrichFind(MathUtils.waveletDerivative(data, scale));
	}

	/**
	 * dietrichFind but calculate derivatives with Savitzky-Golay smoother!
	 * 
	 * @param data
	 * @param polynomialDegree
	 * @param windowSize
	 * @return
	 */
	public static int[] savitzkyGolayDietrichFind(double[] data,
			int polynomialDegree, int windowSize) {
		SavitzkyGolay savitzkyGolay = new SavitzkyGolay();
		savitzkyGolay.setPolynomialDegree(polynomialDegree);
		savitzkyGolay.setWindowSize(windowSize);
		double[][] sgConvolutionFactors = savitzkyGolay.getConvolutionFactors();
		double[] convolutionData = new double[data.length];
		for (int i = 0; i < convolutionData.length; i++)
			convolutionData[i] = 0.0;
		int iRow = 1;
		convolutionData[0] = sgConvolutionFactors[iRow][windowSize];
		for (int i = 1; i <= windowSize; i++) {
			convolutionData[i] = sgConvolutionFactors[iRow][windowSize + i];
			convolutionData[convolutionData.length - i] = sgConvolutionFactors[iRow][windowSize
					- i];
		}
		return dietrichFind(Convolution.convoluteNonPeriodic(data,
				convolutionData));
	}

	/**
	 * 
	 */
	public static double[] histogramBasedPeakFinder(double[] yData,
			double quantile) {
		double[] distMinMax = MathUtils.getMinMax(yData);
		int nPoints = yData.length;
		/*
		 * build a histogram with size of sqrt(nPoints) this value is suggested
		 * in
		 * 
		 * Statistisches Methodenbuch. Verfahren, Fallstudien, Programmcodes
		 * (Statistik und ihre Anwendungen) (Taschenbuch) Helmut Pruscha
		 * 
		 */
		int histogramSize = (int) Math.sqrt(nPoints);
		double[] histogram = new double[histogramSize];
		for (int i = 0; i < histogramSize; i++)
			histogram[i] = 0.0;
		int index;
		for (int i = 0; i < nPoints; i++) {
			index = (int) Math.round((yData[i] - distMinMax[0])
					/ (distMinMax[1] - distMinMax[0]) * (histogramSize - 1));
			histogram[index] += 1;
		}
		for (int i = 0; i < histogramSize; i++)
			histogram[i] /= nPoints;
		// get 10% quantile
		double accumulator = 0.0;
		index = histogramSize - 1;
		while (accumulator < quantile && index >= 0) {
			accumulator += histogram[index--];
		}
		accumulator -= histogram[index + 1];
		if(DEBUG)System.out.println("accumulator=[" + accumulator + "]");
		index += 2;
		double value;
		for (int i = index; i < histogramSize; i++) {
			if (histogram[i] > 1e-10) {
				value = i * (distMinMax[1] - distMinMax[0]) / histogramSize
						+ distMinMax[0];
				if(DEBUG) System.out.println(i + " probability: " + histogram[i]
						+ " base value: " + value);
			}
		}
		double threshold = (index - 1) * (distMinMax[1] - distMinMax[0])
				/ histogramSize + distMinMax[0];
		//
		if(DEBUG)	System.out.println("threshold=[" + threshold + "]");
		int zeroed = 0;
		double[] cleanedUpData = yData.clone();
		for (int i = 0; i < nPoints; i++) {
			// System.out.println(cleanedUpData[i]);
			if (cleanedUpData[i] < threshold) {
				cleanedUpData[i] = 0.0;
				zeroed++;
			} else {
				cleanedUpData[i] -= distMinMax[0];
			}
		}
		if(DEBUG) System.out.println("zeroed=[" + zeroed + "]");
		return cleanedUpData;
	}

	/**
	 * 
	 * @param data
	 * @param windowSize
	 * @param threshhold
	 * @param negative
	 * @return
	 */
	public static int[] findMaxima(double[] data, int windowSize, double threshhold, boolean negative) {
		// double sign = negative ? -1.0 : 1.0;

		return null;
	}

	/**
	 * A peak detection algorithm which works with a simple threshold.
	 * 
	 * 
	 * @param xData
	 * @param yData
	 * @param waveletScale
	 * @param whittakerLambda
	 * @return
	 */
	public static NMRSignal1D[] simpleThresholdedDetection(double[] xData,
			double[] yData, int waveletScale, int whittakerLambda, int nStddev,
			double avgSignal2NoiseThreshold) {
		double[] tmpData = yData.clone();
		int nbDataPoints = yData.length;
		// do a baseline correction first
		double[] baseline = BaselineCorrection.haarWhittakerBaselineCorrection(
				tmpData, waveletScale, whittakerLambda);
		for (int i = 0; i < nbDataPoints; i++)
			tmpData[i] -= baseline[i];
		// calculate the
		// mean and standard deviation by the means of robust statistics
		double[] stats = MathUtils.getRobustMeanAndStddev(tmpData, 0,
				nbDataPoints);
		// calculate a "hard"-threshold as in
		// IEEE Transactions on biomedical engineering, vol. 52, no. 1, january
		// 2005, p. 76-
		double thresh = stats[1] * nStddev;// Math.sqrt(2 *
		// Math.log(nbDataPoints));
		LinkedList<Point> ranges = new LinkedList<Point>();
		for (int i = 0; i < nbDataPoints; i++) {
			if (tmpData[i] > thresh) {
				Point pt = new Point();
				pt.x = i;
				while (i < nbDataPoints - 1 && tmpData[++i] > thresh)
					;
				pt.y = i - 1;
				ranges.add(pt);
			}
		}
		try {
			PrintStream printStream = new PrintStream("pfThr.dat");
			for (int i = 0; i < nbDataPoints; i++) {
				printStream.println(xData[i] + "\t" + yData[i] + "\t"
						+ baseline[i]);
			}
			printStream.close();
		} catch (FileNotFoundException e) {
			e.printStackTrace();
		}

		LinkedList<NMRSignal1D> peaks = new LinkedList<NMRSignal1D>();
		Iterator<Point> iterator = ranges.iterator();
		while (iterator.hasNext()) {
			Point pt = iterator.next();
			int max = MathUtils.findGlobalMaximumIndex(tmpData, pt.x, pt.y);
			if (max != -1) {
				NMRSignal1D peak = new NMRSignal1D(yData[pt.x],yData[pt.y]);
				//peak.setPeakStart(pt.x);
				//peak.setPeakEnd(pt.y);
				/*
				 * A second threshold is based on the average signal to noise
				 * ratio. This has been found to help in the case of noise 13C
				 * spectra
				 */
				double avgSNR = 0.0;
				for (int i = pt.x; i <= pt.y; i++) {
					avgSNR += yData[i] / thresh;
				}
				avgSNR /= (pt.y - pt.x + 1);
				if (avgSNR > avgSignal2NoiseThreshold) {
					peaks.add(peak);
				}
			}
		}
		NMRSignal1D[] peakList = new NMRSignal1D[peaks.size()];
		return peaks.toArray(peakList);
	}
	/**
	 * This method implements a simple peak finder for NMR spectra. The method
	 * starts by applying a baseline correction using
	 * <code>BaselineCorrection.haarWhittakerBaselineCorrection</code>.
	 * 
	 * Next the standard deviation is calculated using robust statistics. Peak
	 * regions are identified as regions where
	 * <code>yData[i] &gt; nbStandardDeviations * standardDeviation</code>.
	 * 
	 * Afterwards the rejoin with the baseline is determined by
	 * <code>yData[i] &lt; nbBaselineRejoinStddev * standardDeviation</code>.
	 * 
	 * @param xData
	 *            abscissa values
	 * @param yData
	 *            ordinate values
	 * @param waveletScale
	 *            the wavelet scale that is used for the internal baseline
	 *            correction
	 * @param whittakerLambda
	 *            the smoothing parameter used in the Whittaker smoother
	 * @param nbStandardDeviations
	 *            number of standard deviations used to discriminate peak
	 *            regions
	 * @param nbBaselineRejoinStddev
	 *            number of standard deviations used to detect the baseline
	 *            rejoin
	 * @return an array of <code>NMRSignal1D</code> objects containint the
	 *         peak regions
	 */
	public static NMRSignal1D[] simpleThresholdedDetectionBSRRejoin(
			double[] xData, double[] yData, int waveletScale,
			int whittakerLambda, double nbStandardDeviations,
			double nbBaselineRejoinStddev) {
		double[] tmpData = yData.clone();
		int nbDataPoints = yData.length;
		// do a baseline correction first
		double[] baseline = BaselineCorrection.haarWhittakerBaselineCorrection(
				tmpData, waveletScale, whittakerLambda);
		for (int i = 0; i < nbDataPoints; i++)
			tmpData[i] -= baseline[i];
		// calculate the
		// mean and standard deviation by the means of robust statistics
		double[] stats = MathUtils.getRobustMeanAndStddev(tmpData, 0,
				nbDataPoints);
		// calculate a "hard"-threshold as in
		// IEEE Transactions on biomedical engineering, vol. 52, no. 1, january
		// 2005, p. 76-
		// keep the number of standard deviations variable
		double standardDeviation = stats[1];
		double peakThreshold = standardDeviation * nbStandardDeviations;
		LinkedList<Point> ranges = new LinkedList<Point>();
		for (int i = 0; i < nbDataPoints; i++) {
			if (tmpData[i] > peakThreshold) {
				Point pt = new Point();
				pt.x = i;
				while (i < nbDataPoints - 1 && tmpData[++i] > peakThreshold)
					;
				pt.y = i - 1;
				ranges.add(pt);
			}
		}

		Iterator<Point> iterator = ranges.iterator();
		// handle rejoining of baseline
		boolean[] bitmask = new boolean[nbDataPoints];
		Arrays.fill(bitmask, false);
		double baselineRejoin = standardDeviation * nbBaselineRejoinStddev;
		while (iterator.hasNext()) {
			Point pt = iterator.next();
			Arrays.fill(bitmask, pt.x, pt.y + 1, true);
			int i = pt.x - 1;
			while (i > 0 && tmpData[i] > baselineRejoin && !bitmask[i])
				bitmask[i--] = true;
			i = pt.y + 1;
			while (i < nbDataPoints && yData[i] > baselineRejoin && !bitmask[i])
				bitmask[i++] = true;
		}
		LinkedList<NMRSignal1D> peaks = new LinkedList<NMRSignal1D>();
		// double[] secondDer = MathUtils.waveletDerivative(tmpData, 5, 2);
		for (int i = 0; i < nbDataPoints; i++) {
			if (bitmask[i]) {
				Point pt = new Point();
				pt.x=i;
				
				//peak.setPeakStart(i);
				while (i < nbDataPoints && bitmask[++i]);
				
				pt.y=i;
				NMRSignal1D peak = new NMRSignal1D(xData[pt.x],xData[pt.y]);
				// peak.setPeakEnd(i);
				// int start = (int) peak.getPeakStart() + 1;
				// int end = (int) peak.getPeakEnd() - 1;
				// for (int iSecondDer = start; iSecondDer <= end; iSecondDer++)
				// {
				// if (secondDer[iSecondDer] < 0 && tmpData[iSecondDer] >
				// peakThreshold) {
				// int a = iSecondDer;
				// while (iSecondDer < end && secondDer[++iSecondDer] < 0)
				// ;
				// int b = iSecondDer;
				// int peakPosition = MathUtils.findGlobalMaximumIndex(yData, a,
				// b+1);
				// peak.addPeakLocation(peakPosition);
				// }
				// }
				for (int j = pt.x + 1; j < pt.y - 1; j++) {
					if (tmpData[j] > peakThreshold
							&& tmpData[j - 1] < tmpData[j]
							&& tmpData[j + 1] < tmpData[j]) {
						peak.addPeak(xData[j], tmpData[j]);//addPeakLocation(j);
					}
				}

				//peak.setAppliedThreshold(baselineRejoin);
				peaks.add(peak);
			}
		}

		NMRSignal1D[] peakList = new NMRSignal1D[peaks.size()];
		return peaks.toArray(peakList);
	}

	public static NMRSignal1D[] simpleThresholdedDetectionBSRRejoin(SpectraData spectraData, double[] inData, int from, int to,
			double nbStandardDeviations, double nbBaselineRejoinStddev) {
		return PeakFinders.simpleThresholdedDetectionBSRRejoinWorker(
				spectraData, inData, from, to, nbStandardDeviations,
				nbBaselineRejoinStddev);
	}

	public static NMRSignal1D[] simpleThresholdedDetectionBSRRejoin(
			SpectraData spectraData, double[] inData, int from, int to,
			int waveletScale, int whittakerLambda, double nbStandardDeviations,
			double nbBaselineRejoinStddev) {
		double[] tmpData = inData.clone();
		int nbDataPoints = inData.length;
		// do a baseline correction first
		double[] baseline = BaselineCorrection.haarWhittakerBaselineCorrection(
				tmpData, waveletScale, whittakerLambda);
		for (int i = 0; i < nbDataPoints; i++)
			tmpData[i] -= baseline[i];
		return PeakFinders.simpleThresholdedDetectionBSRRejoinWorker(
				spectraData, tmpData, from, to, nbStandardDeviations,
				nbBaselineRejoinStddev);
	}
	
	public static NMRSignal1D[] simpleThresholdedDetectionBSRRejoinWorker(
			SpectraData spectraData, double[] inData, int from, int to,
			double nbStandardDeviations, double nbBaselineRejoinStddev) {
		int nbDataPoints = inData.length;
		// calculate the
		// mean and standard deviation by the means of robust statistics
		double[] stats = MathUtils.getRobustMeanAndStddev(inData, 0, nbDataPoints);
		// calculate a "hard"-threshold as in
		// IEEE Transactions on biomedical engineering, vol. 52, no. 1, january
		// 2005, p. 76-
		// keep the number of standard deviations variable
		//nbStandardDeviations=1;
		double standardDeviation = stats[1];
		double peakThreshold = standardDeviation * nbStandardDeviations;
		
		boolean[] bitmask = new boolean[nbDataPoints];
		Arrays.fill(bitmask, false);
		// LinkedList<Point> ranges = new LinkedList<Point>();
		//peakThreshold*=0.3;
		// 
		for (int i = from; i < to; i++) {
			if (inData[i] > peakThreshold) {
				bitmask[i] = true;
			}
		}
		// handle rejoining of baseline
		double baselineRejoin = standardDeviation * nbBaselineRejoinStddev;
		if(DEBUG) System.out.println(baselineRejoin+" "+peakThreshold);
		for (int i = from + 1; i < to - 1; i++) {
			// 1 -> 0
			if (bitmask[i] && !bitmask[i + 1]) {
				int j = i + 1;
				while (inData[j] > baselineRejoin && j < to)
					bitmask[j++] = true;
			} else if (!bitmask[i] && bitmask[i + 1]) {
				// 0 -> 1
				int j = i;
				while (inData[j] > baselineRejoin && j > from - 1)
					bitmask[j--] = true;
			}
		}

		LinkedList<NMRSignal1D> peaks = new LinkedList<NMRSignal1D>();
		Vector<Integer> subPeakStack = new Vector<Integer>();
		//System.out.println("gwewwwww "+from+" "+to);
		for (int i = from; i < to; i++) {
			//System.out.println(i);
			if (bitmask[i]) {
				Point pt = new Point();
				//NMRSignal1D peak = new NMRSignal1D();
				pt.x=i;
				//peak.setPeakStart(i);
				//peak.setIntStart(i);
				
				// we will find a zone where the points are over the noise
				//System.out.println("ddsfsdfs");
				while (i < to && bitmask[++i]);
				//System.out.println("ddsfsdfs");
				pt.y=i;
				NMRSignal1D peak = new NMRSignal1D(spectraData.arrayPointToUnits(pt.x),spectraData.arrayPointToUnits(pt.y));
				peak.setObserve( spectraData.getParamDouble("$BF1",0.0));
				peak.setUnits(spectraData.getXUnits());
				peak.setNucleus(spectraData.getNucleus());
				//peak.setPeakEnd(i);
				//peak.setIntEnd(i);
				//peakThreshold=3.2;

				// The following has be changed by LP on 20100120
				// we need to select the points that are considered as peaks based on maxima

				/*
				for (int j = (int) peak.getPeakStart(); j < (int)peak.getPeakEnd(); j++) {
					System.out.println(j+" - "+inData[j]);
				}
				*/
				
				
				for (int j = pt.x + 1; j < pt.y - 1; j++) {
					// the point should be bigger that the peakThreshold and also bigger that the point before and after
					if (inData[j] > peakThreshold && inData[j - 1] < inData[j] && inData[j + 1] < inData[j]) {
						subPeakStack.add(j);
						// System.out.println("Found a top ("+subPeakStack.size()+"): "+inData[j]);
					}
				}
				//System.out.println("dddd");
				// we need also to remove the points that seems rather close to noise or impurities
				// we check if 2 consecutive peaks have a ratio bigger than RATIO. In this case the the threshold is the height of the smaller peak
				int RATIO=10;
				double newThreshold=peakThreshold;
				for (int iSubPeak = 1; iSubPeak < (subPeakStack.size()); iSubPeak++) {
					if (inData[subPeakStack.get(iSubPeak-1)]/inData[subPeakStack.get(iSubPeak)]>RATIO) {
						if (inData[subPeakStack.get(iSubPeak-1)]/2<newThreshold) newThreshold=inData[subPeakStack.get(iSubPeak-1)]/2;
					//	System.out.println("Old Threshold: "+peakThreshold+" - New Threshold :"+newThreshold);
					} else if (inData[subPeakStack.get(iSubPeak)]/inData[subPeakStack.get(iSubPeak-1)]>RATIO) {
						if (inData[subPeakStack.get(iSubPeak)]/2<newThreshold) newThreshold=inData[subPeakStack.get(iSubPeak)]/2;
					//	System.out.println("Old Threshold: "+peakThreshold+" - New Threshold :"+newThreshold);
					}
				}
				
				//System.out.println("dfdfdf");
				for (int iSubPeak = 0; iSubPeak < subPeakStack.size(); iSubPeak++) {
					if (inData[subPeakStack.get(iSubPeak)] > newThreshold) {
						// System.out.println("ADD");
						peak.addPeak(spectraData.getX(subPeakStack.get(iSubPeak)), spectraData.getY(subPeakStack.get(iSubPeak)));
						//peak.addPeakLocation(subPeakStack.get(iSubPeak));
					}
				}
				// we added all the peaks we should now empty our stack
				subPeakStack = new Vector<Integer>();
				
				//peak.setAppliedThreshold(baselineRejoin);
				double integral = MathUtils.numericalIntegralForward(inData,
						1.0, pt.x, (int) (pt.y - pt.x + 1));
				
				IntegralData integraldata = new IntegralData(peak.getStartX(),peak.getEndX(),integral);
				peak.setIntegralData(integraldata);
				peaks.add(peak);
			}
		}
		
		//System.out.println(peaks.size());
		NMRSignal1D[] peakList = new NMRSignal1D[peaks.size()];
		peakList = peaks.toArray(peakList);
		//System.out.println("XX1 "+peakList[0].getShift()+" "+peakList.length);
		//System.out.println(peakList.length);
		/*
		 * if two peaks are separated less than 10 Hz we are not able to
		 * distinguish if they belong to each other and we need to join them.
		 * Also, we can remove all of this peaks which their integral is smaller
		 * than 0.005 folds the biggest one.
		 */
		if (spectraData.getNucleus() == Nucleus.NUC_1H && peakList.length > 1) {
			peaks.clear();
			Arrays.sort(peakList);
			int iNext = 1;
			peaks.add(peakList[0]);
			double baseFrequency = spectraData.getParamDouble("$BF1", 400.0);
			//double limit = Math.abs(10.0 / baseFrequency);
			double limit = Math.abs(3.0 / baseFrequency);
			double max=0,tmp;
			//System.out.println("Limit: "+limit);
			while (iNext < peakList.length) {
				NMRSignal1D currentPeak = peaks.getLast();
				//System.out.println("C "+currentPeak.getShift()+" "+currentPeak.getStartX()+" "+currentPeak.getEndX()+" "+currentPeak.getNbPeaks());
				NMRSignal1D nextPeak = peakList[iNext++];
				//System.out.println("N "+nextPeak.getShift()+" "+nextPeak.getStartX()+" "+nextPeak.getEndX()+" "+nextPeak.getNbPeaks());
				if (nextPeak.getNbPeaks() > 0) {
					//if(currentPeak.getNbPeaks()>1)
					//	System.out.println(currentPeak.getPeak(0).getX()+" "+currentPeak.getPeak(1).getX());
					double delta = Math.abs(currentPeak.getStartX()- nextPeak.getEndX());
					//double delta = Math.abs(currentPeak.getP- nextPeak.getEndX());
					//System.out.println("delta "+delta);
					//System.out.println(nextPeak.getStartX()+" "+nextPeak.getEndX()+" "+currentPeak.getStartX()+" "+currentPeak.getEndX()+" delta: "+delta);
					tmp=nextPeak.getIntegralData().getValue();
					if (delta < limit) {
						currentPeak.joinWith(nextPeak);
						tmp=currentPeak.getIntegralData().getValue();
					} else {
						peaks.add(nextPeak);
					}
					if(tmp>max)
						max=tmp;
				}
			}
			max*=0.005;
			for(int i=peaks.size()-1;i>=0;i--){
				if(peaks.get(i).getIntegralData().getValue()<max)
					peaks.remove(i);
			}
			peakList = new NMRSignal1D[peaks.size()];
			peakList = peaks.toArray(peakList);
		}
		//System.out.println("XX2 "+peakList[0].getShift()+" "+peakList.length);
		return peakList;
	}

	/**
	 * Returns an array of NMRSignal1D containing only one Peak with the middle value between min and max
	 * NEED TO SELECT THE ACTIVE SUBSPECTRADATA BEFORE
	 */
	@Deprecated
	public static NMRSignal1D  middleFinder(double x0, double xn, SpectraData spectraData) {
		NMRSignal1D newPeak = new NMRSignal1D(Math.min(x0, xn),Math.min(x0, xn));
		newPeak.addPeak((x0+xn)/2.0,spectraData.getY(spectraData.unitsToArrayPoint((x0+xn)/2.0)));
		newPeak.setNucleus(spectraData.getNucleus());
		return newPeak;

	}
	
	/**
	 * Returns an NMRSignal1D containing only one Peak with the middle value between min and max
	 * NEED TO SELECT THE ACTIVE SUBSPECTRADATA BEFORE
	 */
	public static NMRSignal1D  middleFinder2(double x0, double xn, SpectraData spectraData) {
		double startX = Math.min(x0, xn);
		double endX = Math.max(x0, xn);
		double observe = spectraData.getParamDouble("observefrequency",0);
		String units =spectraData.getXUnits();
		NMRSignal1D newPeak = new NMRSignal1D(startX,endX,observe,units);
		newPeak.setNucleus(spectraData.getNucleus());
		newPeak.addPeak((x0+xn)/2,1);
		newPeak.forceAssymetric();
		return newPeak;
		/*double startX = Math.min(spectraData.unitsToArrayPoint(x0), spectraData.unitsToArrayPoint(xn));
		double endX = Math.max(spectraData.unitsToArrayPoint(x0), spectraData.unitsToArrayPoint(xn));
		double observe = spectraData.getParamDouble("observefrequency",0);
		String units =spectraData.getXUnits();
		NMRSignal1D newPeak = new NMRSignal1D(startX,endX,observe,units);
		newPeak.addPeak(spectraData.unitsToArrayPoint((x0+xn)/2),1);
		newPeak.forceAssymetric();
		return newPeak;*/
	}
	
	
	/**
	 * This function is executed on the activeElement of spectraData. This has be set BEFORE !!!
	 * @param x0
	 * @param xn
	 * @param SpectraData
	 * @return
	 */
	public static NMRSignal1D[] simpleThresholdedDetectionBSRRejoin(double x0, double xn, SpectraData spectraData) {
		int i0 = Math.min(spectraData.unitsToArrayPoint(x0), spectraData.unitsToArrayPoint(xn));
		int in = Math.max(spectraData.unitsToArrayPoint(x0), spectraData.unitsToArrayPoint(xn));
		int nPoints = in - i0 + 1;
		double[] data = new double[nPoints];
		boolean[] bitmask = new boolean[nPoints];
		// double dx = spectraData.getInterval();
		
		spectraData.setActiveElement(0);
		int nbPoints = spectraData.getNbPoints();
		/*double[] data = new double[nbPoints];
		for (int iPoint = 0; iPoint < nbPoints; iPoint++)
			data[iPoint] = spectraData.getY(iPoint);*/
		double noise = MathUtils.getRobustMeanAndStddev(spectraData.getSpectraDataY(), 0, nbPoints)[1];
		//double noise = spectraData.getRobustNoiseLevel();
		double thresh = spectraData.getNStddevPeakDetection() * noise;
		double threshBaselineRejoin = spectraData.getNStddevBaseline() * noise;

		for (int i = 0; i < nPoints; i++) {
			data[i] = spectraData.getY(i + i0);
			if (data[i] > thresh)
				bitmask[i] = true;
		}
		for (int i = 0; i < nPoints - 1; i++)
			if (bitmask[i] && !bitmask[i + 1]
					&& data[i + 1] > threshBaselineRejoin)
				bitmask[i + 1] = true;
		for (int i = nPoints - 2; i >= 0; i--)
			if (!bitmask[i] && bitmask[i + 1] && data[i] > threshBaselineRejoin)
				bitmask[i] = true;

		LinkedList<NMRSignal1D> peaks = new LinkedList<NMRSignal1D>();
		int ia, ib;
		double tmp;
		double baseFrequency = spectraData.getParamDouble("$BF1", 0.0);
		String units =spectraData.getXUnits();
		for (int i = 0; i < nPoints - 1; i++) {
			if (bitmask[i]) {
				ia = i;
				tmp=spectraData.arrayPointToUnits(i0 + i);
				//newPeak.setAppliedThreshold(threshBaselineRejoin);
				//newPeak.setPeakStart(spectraData.arrayPointToUnits(i0 + i));
				
				while (i < nPoints - 1 && bitmask[++i])
					;
				ib = i - 1;

				NMRSignal1D newPeak = new NMRSignal1D(tmp,spectraData.arrayPointToUnits(i0 + ib),baseFrequency,units);
				newPeak.setNucleus(spectraData.getNucleus());
				//newPeak.setPeakEnd(spectraData.arrayPointToUnits(i0 + ib));
				peaks.add(newPeak);
				for (int j = ia; j <= ib; j++) {
					if (data[j] > thresh && data[j - 1] < data[j]
							&& data[j + 1] < data[j]) {
						newPeak.addPeak(spectraData.arrayPointToUnits(i0
								+ j),spectraData.getY(i0+j));
					}
				}
			}
		}
		NMRSignal1D[] peakList = new NMRSignal1D[peaks.size()];
		return peaks.toArray(peakList);
	}

	public static double getNMRBaselineRejoinThreshold(Nucleus nucleus) {
		if (nucleus == Nucleus.NUC_1H)
			return 1.0;
		if (nucleus == Nucleus.NUC_13C)
			return 3.0;
		return 1.0;
	}

	public static double getNMRPeakThreshold(Nucleus nucleus) {
		
		if (nucleus == Nucleus.NUC_1H)
			return 3.0;
		if (nucleus == Nucleus.NUC_13C)
			return 5.0;
		return 1.0;
	}

	public static NMRSignal1D[] simpleThresholdedDetectionSder(
			double[] xData, double[] yData, int waveletScale,
			int whittakerLambda) {
		double[] tmpData = yData.clone();
		int nbDataPoints = yData.length;
		double[] baseline = BaselineCorrection.haarWhittakerBaselineCorrection(
				tmpData, waveletScale, whittakerLambda);
		for (int i = 0; i < nbDataPoints; i++)
			tmpData[i] -= baseline[i];
		double[] secondDerivative = MathUtils.waveletDerivative(tmpData,
				waveletScale, 2);
		double[] stats = MathUtils.getRobustMeanAndStddev(tmpData, 0,
				nbDataPoints);
		double thresh = stats[1] * Math.sqrt(2 * Math.log(nbDataPoints));
		LinkedList<Point> ranges = new LinkedList<Point>();
		for (int i = 0; i < nbDataPoints; i++) {
			if (tmpData[i] > thresh && secondDerivative[i] < 0) {
				Point pt = new Point();
				pt.x = i;
				while (++i < nbDataPoints - 1 && tmpData[i] > thresh
						&& secondDerivative[i] < 0)
					;
				pt.y = i - 1;
				ranges.add(pt);
			}
		}
		try {
			PrintStream printStream = new PrintStream("pfThr.dat");
			for (int i = 0; i < nbDataPoints; i++) {
				printStream.println(xData[i] + "\t" + yData[i] + "\t"
						+ baseline[i]);
			}
			printStream.close();
		} catch (FileNotFoundException e) {
			e.printStackTrace();
		}

		LinkedList<NMRSignal1D> peaks = new LinkedList<NMRSignal1D>();
		Iterator<Point> iterator = ranges.iterator();
		while (iterator.hasNext()) {
			Point pt = iterator.next();
			int max = MathUtils.findGlobalMaximumIndex(tmpData, pt.x, pt.y);
			if (max != -1) {
				NMRSignal1D peak = new NMRSignal1D(xData[pt.x],xData[pt.y]);
				peak.addPeak(xData[max],yData[max]);
				//peak.setPeakStart(xData[pt.x]);
				//peak.setPeakEnd(xData[pt.y]);
				//peak.addPeakLocation(xData[max]);
				peaks.add(peak);
			}
		}
		NMRSignal1D[] peakList = new NMRSignal1D[peaks.size()];
		return peaks.toArray(peakList);
	}

	public static NMRSignal1D[] pfSecondDer(double[] xData, double[] yData,
			int waveletScale, int whittakerLambda) {
		double[] tmpData = yData.clone();
		int nbDataPoints = yData.length;
		// double[] firstDer = MathUtils.waveletDerivative(tmpData,
		// waveletScale, 1);
		double[] secondDer = MathUtils.waveletDerivative(tmpData, waveletScale,
				2);
		double[] stats = MathUtils.getRobustMeanAndStddev(secondDer, 0,
				nbDataPoints);
		double thresh = stats[1] * Math.sqrt(2 * Math.log(nbDataPoints));

		LinkedList<Point> ranges = new LinkedList<Point>();
		for (int i = 0; i < nbDataPoints; i++) {
			if (secondDer[i] < -thresh) {
				Point pt = new Point();
				pt.x = i;
				while (i < nbDataPoints - 1 && secondDer[++i] < -thresh)
					;
				pt.y = i - 1;
				ranges.add(pt);
			}
		}
		LinkedList<NMRSignal1D> peaks = new LinkedList<NMRSignal1D>();
		Iterator<Point> iterator = ranges.iterator();
		while (iterator.hasNext()) {
			Point pt = iterator.next();
			int max = MathUtils.findGlobalMaximumIndex(tmpData, pt.x, pt.y);
			if (max != -1) {
				NMRSignal1D peak = new NMRSignal1D(xData[pt.x],xData[pt.y]);
				peak.addPeak(xData[max],yData[max]);
				//peak.setPeakStart(xData[pt.x]);
				//peak.setPeakEnd(xData[pt.y]);
				//peak.addPeakLocation(xData[max]);
				peaks.add(peak);
			}
		}
		NMRSignal1D[] peakList = new NMRSignal1D[peaks.size()];
		return peaks.toArray(peakList);
	}

	public static NMRSignal1D[] pf(double[] xData, double[] yData,
			int waveletScale, int whittakerLambda) {
		double[] tmpData = yData.clone();
		int nbDataPoints = yData.length;
		double[] baseline = BaselineCorrection.haarWhittakerBaselineCorrection(
				tmpData, waveletScale, whittakerLambda);
		for (int i = 0; i < nbDataPoints; i++)
			tmpData[i] -= baseline[i];
		double[] dataStats = MathUtils.getAverageAndVariance(tmpData, 0,
				nbDataPoints);
		double average = dataStats[0];
		double stddev = Math.sqrt(dataStats[1]);
		double threshold = average + 1 * stddev;
		double[] secondDerivative = MathUtils.waveletDerivative(tmpData,
				waveletScale, 2);
		LinkedList<NMRSignal1D> linkedList = new LinkedList<NMRSignal1D>();
		NMRSignal1D currentPeak = null;
		double currentMaximum = Double.MIN_VALUE;
		for (int i = waveletScale; i < nbDataPoints - waveletScale; i++) {
			// secondDerivative[i] < 0 &&
			if (secondDerivative[i] < 0 && tmpData[i] > threshold) {
				if (currentPeak == null) {
					currentPeak = new NMRSignal1D(0,0);
					currentPeak.setStartX(xData[i]);
					//currentPeak.setAppliedThreshold(threshold);
				} else {
					//currentPeak.setPeakEnd(i);
					currentPeak.setEndX(xData[i]);
				}
				if (yData[i] > currentMaximum) {
					currentMaximum = yData[i];
					currentPeak.addPeak(xData[i],yData[i]);
				}
			} else {
				if (currentPeak != null) {
					linkedList.add(currentPeak);
					currentMaximum = Double.MIN_VALUE;
					currentPeak = null;
				}
			}
		}
		NMRSignal1D[] peakArray = null;
		if (linkedList.size() > 0) {
			int nPeaks = linkedList.size();
			peakArray = new NMRSignal1D[nPeaks];
			for (int i = 0; i < nPeaks; i++)
				peakArray[i] = linkedList.removeFirst();
			Arrays.sort(peakArray);
		}
		return peakArray;
	}

	public static AsymmetricPeak[] pfIEEE(double[] xData, double[] yData) {
		MHPeakFinderStatistical pfinder = new MHPeakFinderStatistical();
		pfinder.setMinimumWaveletSamples(60);
		pfinder.setScales(1, 1, 1);
		pfinder.setData(xData, yData);
		return pfinder.getPeaks();
	}
}
