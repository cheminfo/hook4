package org.cheminfo.hook.nemo.nmr.prediction;

import com.actelion.research.chem.*;
import com.actelion.research.chem.contrib.HydrogenHandler;
import com.actelion.research.epfl.EPFLUtils;
import com.actelion.research.epfl.StereoInfo;
import org.cheminfo.hook.optimizer.HungarianAlgorithm;

import java.io.*;
import java.util.TreeMap;
import java.util.Vector;

/**
 * 
 * This program remaps the atom IDs of the molfiles generated by moloc to the
 * ones used in nemo.
 * 
 * @author engeler
 * 
 */
public class IDRemapper {
	private static final boolean DEBUG = false;

	private File inputMolfile;
	
	private StereoMolecule initialMolecule = null;
	private StereoMolecule compactMolecule = null;
	private StereoMolecule enhancedMolecule = null;
	private StereoInfo[] stereoInfo = null;
	private int[] symRanks = null;
	private int[] indeces = null;

	private Vector<MolFileAtomEntry> atomEntries = null;

	public IDRemapper(File inputMolfile) {
		this.inputMolfile = inputMolfile;
	}

	public void remap() {
		MolfileParser molfileParser = new MolfileParser();
		this.initialMolecule = new StereoMolecule();
		if (!molfileParser.parse(this.initialMolecule, this.inputMolfile)) {
			return;
		}
		this.initialMolecule.ensureHelperArrays(2);
		this.readMolFile();
		this.determineInitialIndexes();
		this.generateHelperMolecules();
		this.fixHydrogenIDs();
		this.assignSymRanks();
		for (int i = 0; i < this.atomEntries.size(); i++) {
			System.out.println(i + "\t" + this.enhancedMolecule.getAtomicNo(this.atomEntries.get(i).getFinalID())+ "\t" +this.atomEntries.get(i).getFinalID() + "\t");
		}
	}

	public TreeMap<Integer, Integer> getIDMap() {
		TreeMap<Integer, Integer> map = new TreeMap<Integer, Integer>();
		for (int iAtom = 0; iAtom < this.atomEntries.size(); iAtom++) {
			map.put(this.atomEntries.get(iAtom).getMolFileID(),
					this.atomEntries.get(iAtom).getFinalID());
		}
		return map;
	}

	public void outputMap() {
		for (int iAtom = 0; iAtom < this.atomEntries.size(); iAtom++) {
			MolFileAtomEntry current = this.atomEntries.get(iAtom);
			System.out.println(current.getMolFileID() + "\t"
					+ current.getFinalID() + "\t" + current.getSymmetryRank());
		}
	}

	private void assignSymRanks() {
		for (int iAtom = 0; iAtom < this.atomEntries.size(); iAtom++) {
			MolFileAtomEntry current = this.atomEntries.get(iAtom);
			if (current.getAtomicNo() == 1) {
				if (this.stereoInfo[current.getFinalID()] == StereoInfo.UNDEF) {
					current.setSymmetryRank(this.symRanks[this.atomEntries.get(
							current.getMolFileID()).getFinalID()]);
				} else {
					current.setSymmetryRank(this.symRanks[current.getMolFileID()]);
				}
			} else {
				current.setSymmetryRank(this.symRanks[current.getFinalID()]);
			}
		}
	}

	private void fixHydrogenIDs() {
		for (int iEntry = 0; iEntry < this.atomEntries.size(); iEntry++) {
			MolFileAtomEntry currentEntry = this.atomEntries.get(iEntry);
			if (currentEntry.getAtomicNo() != 1 && this.initialMolecule.getAllHydrogens(currentEntry.getActelionSortedID()) > 0) {
				if (this.stereoInfo[currentEntry.getFinalID()] == StereoInfo.UNDEF) {
					this.handleEquivalentProtons(currentEntry);
				} else {
					int nProtons = this.initialMolecule.getAllHydrogens(currentEntry.getActelionSortedID());
					if (currentEntry.getAtomicNo() == 6) {
						if (this.enhancedMolecule.getAllConnAtoms(currentEntry.getFinalID()) == 4) {
							// CH2
							this.resolveDiaCH2(currentEntry);
						} else if (this.enhancedMolecule.getAllConnAtoms(currentEntry.getFinalID()) == 3) {
							// double bonds
							this.resolveEZ(currentEntry);
						}
					} else if (currentEntry.getAtomicNo() == 7 && nProtons == 2) {
						// amide and the like
						this.handleAmideProtons(currentEntry);
					} else {
						// the ID assignment is unique as we only have one
						// proton
						this.handleAmideProtons(currentEntry);
					}
				}
			}
		}
	}

	/**
	 * Handle Amide protons
	 * 
	 * @param currentAtom
	 */
	private void handleAmideProtons(MolFileAtomEntry currentAtom) {
		int iNitrogenAtom = currentAtom.getFinalID();
		int[] substituents = new int[3];
		int[] atomicNos = new int[3];
		int nSubstituents = 0;
		int iCarbonylOxygen = -1;
		for (int i = 0; i < this.enhancedMolecule
				.getAllConnAtoms(iNitrogenAtom); i++) {
			int iConn = this.enhancedMolecule.getConnAtom(iNitrogenAtom, i);
			int atomicNo = this.enhancedMolecule.getAtomicNo(iConn);
			System.out.println(atomicNo);
			if (atomicNo == 6
					&& iCarbonylOxygen == -1
					&& (iCarbonylOxygen = EPFLUtils.getCarbonylOxygen(
							this.enhancedMolecule, iConn)) != -1) {
			} else {
				substituents[nSubstituents] = iConn;
				atomicNos[nSubstituents] = atomicNo;
				nSubstituents++;
			}
		}
		// nothing found
		if (iCarbonylOxygen == -1 || nSubstituents != 2) {
			this.handleEquivalentProtons(currentAtom);
			return;
		}
		double d1 = EPFLUtils.getDistance(enhancedMolecule, iCarbonylOxygen,
				substituents[0]);
		double d2 = EPFLUtils.getDistance(enhancedMolecule, iCarbonylOxygen,
				substituents[1]);

		int proE_ID = -1;
		int proZ_ID = -1;
		if (d1 < d2) {
			// d1 - pro Z
			proZ_ID = substituents[0];
			// d2 - pro E
			proE_ID = substituents[1];
		} else {
			// d1 - pro E
			proE_ID = substituents[0];
			// d2 - pro Z
			proZ_ID = substituents[1];
		}
		//
		MolFileAtomEntry carbonylOxEntry = null;
		for (int i = 0; i < this.atomEntries.size(); i++) {
			if (this.atomEntries.get(i).getFinalID() == iCarbonylOxygen) {
				carbonylOxEntry = this.atomEntries.get(i);
				break;
			}
		}
		if (carbonylOxEntry == null) {
			System.out.println("carbonyl oxygen not found");
			System.exit(-1);
		}
		// get H's from initial molecule
		MolFileAtomEntry[] initialHydrogens = new MolFileAtomEntry[2];
		int iHPointer = 0;
		for (int i = 0; i < currentAtom.getAllNeighbours(); i++) {
			int iNeighbour = currentAtom.getNeighbour(i);
			if (this.atomEntries.get(iNeighbour).getAtomicNo() == 1)
				initialHydrogens[iHPointer++] = this.atomEntries
						.get(iNeighbour);
		}
		if (iHPointer != 2) {
			System.out.println("missing a proton");
			System.exit(-1);
		}
		d1 = carbonylOxEntry.getDistance(initialHydrogens[0]);
		d2 = carbonylOxEntry.getDistance(initialHydrogens[1]);
		if (d1 < d2) {
			initialHydrogens[0].setFinalID(proZ_ID);
			initialHydrogens[1].setFinalID(proE_ID);
		} else {
			initialHydrogens[0].setFinalID(proE_ID);
			initialHydrogens[1].setFinalID(proZ_ID);
		}
	}

	/**
	 * Assigns the the hydrogen IDs for diastereotopic protons by substitution
	 * 
	 * @param currentAtom
	 */
	private void resolveDiaCH2(MolFileAtomEntry currentAtom) {
		StereoMolecule testMolecule = new StereoMolecule();
		// this.compactMolecule.copyMolecule(testMolecule);
		EPFLUtils.copyMolecule(this.compactMolecule, testMolecule, true);
		MolFileAtomEntry[] molfileHydrogens = new MolFileAtomEntry[2];
		int finalID = currentAtom.getFinalID();
		int stackPointer;
		stackPointer = 0;
		// get the neighbouring atom entities
		for (int i = 0; i < currentAtom.getAllNeighbours(); i++) {
			int iMolfileID = currentAtom.getNeighbour(i);
			if (this.atomEntries.get(iMolfileID).getAtomicNo() == 1) {
				molfileHydrogens[stackPointer++] = this.atomEntries
						.get(iMolfileID);
			}
		}
		// get hydrogen ID's from enhanced molecule
		stackPointer = 0;
		int[] enhancedHydrogenIDs = new int[2];
		for (int i = 0; i < this.enhancedMolecule.getAllConnAtoms(finalID); i++) {
			if (this.enhancedMolecule.getAtomicNo(this.enhancedMolecule
					.getConnAtom(finalID, i)) == 1) {
				enhancedHydrogenIDs[stackPointer++] = this.enhancedMolecule
						.getConnAtom(finalID, i);
			}
		}

		// replace the first atom
		int avlAtomicNo = EPFLUtils.getReplacementAtom(this.enhancedMolecule);
		int iNewAtom = testMolecule.addAtom(avlAtomicNo);
		testMolecule.setAtomX(iNewAtom, molfileHydrogens[0].getX());
		testMolecule.setAtomY(iNewAtom, molfileHydrogens[0].getY());
		testMolecule.setAtomZ(iNewAtom, molfileHydrogens[0].getZ());
		testMolecule.addBond(finalID, iNewAtom, Molecule.cBondTypeSingle);
		iNewAtom = testMolecule.addAtom(1);
		testMolecule.setAtomX(iNewAtom, molfileHydrogens[1].getX());
		testMolecule.setAtomY(iNewAtom, molfileHydrogens[1].getY());
		testMolecule.setAtomZ(iNewAtom, molfileHydrogens[1].getZ());
		testMolecule.addBond(finalID, iNewAtom, Molecule.cBondTypeSingle);
		Canonizer canonizer = new Canonizer(testMolecule);
		String idcode = canonizer.getIDCode();
		String coordinates = canonizer.getEncodedCoordinates(true);
		int[] finalIndexes1 = canonizer.getGraphIndexes();
		int targetID = finalIndexes1[finalID];
		if (DEBUG) {
			String molfile = (new MolfileCreator(testMolecule)).getMolfile();
			try {
				PrintWriter writer = new PrintWriter("testMolecule.mol");
				writer.println(molfile);
				writer.close();
			} catch (FileNotFoundException e) {
				e.printStackTrace();
			}

		}
		IDCodeParser parser = new IDCodeParser();
		testMolecule = parser.getCompactMolecule(idcode, coordinates);
		boolean canAssign = false;
		boolean swapOrder = false;
		if (testMolecule.getAtomCIPParity(targetID) == Molecule.cAtomCIPParityRorM) {
			if (DEBUG)
				System.out.println("First atom pro R");
			canAssign = true;
			if (this.stereoInfo[enhancedHydrogenIDs[0]] == StereoInfo.PRO_R) {
				swapOrder = false;
			} else {
				swapOrder = true;
			}
		} else if (testMolecule.getAtomCIPParity(targetID) == Molecule.cAtomCIPParitySorP) {
			if (DEBUG)
				System.out.println("First atom pro S");
			canAssign = true;
			if (this.stereoInfo[enhancedHydrogenIDs[0]] == StereoInfo.PRO_S) {
				swapOrder = false;
			} else {
				swapOrder = true;
			}
		}
		if (canAssign) {
			if (swapOrder) {
				molfileHydrogens[0].setFinalID(enhancedHydrogenIDs[1]);
				molfileHydrogens[1].setFinalID(enhancedHydrogenIDs[0]);
			} else {
				molfileHydrogens[0].setFinalID(enhancedHydrogenIDs[0]);
				molfileHydrogens[1].setFinalID(enhancedHydrogenIDs[1]);
			}
		} else {
			System.out.println("Problematic assignment");
		}

	}

	/**
	 * Assigns the hydrogen IDs for E/Z protons by substitution
	 * 
	 * @param currentAtom
	 */
	private void resolveEZ(MolFileAtomEntry currentAtom) {
		System.out.println("Resolving EZ for: "+currentAtom);
		
		StereoMolecule testMolecule = new StereoMolecule();
		if (DEBUG) {
			String molfile = (new MolfileCreator(this.compactMolecule)).getMolfile();
			try {
				PrintWriter writer = new PrintWriter("testCompact.mol");
				writer.println(molfile);
				writer.close();
			} catch (FileNotFoundException e) {
				e.printStackTrace();
			}
		}
		EPFLUtils.copyMolecule(this.compactMolecule, testMolecule, true);
		if (DEBUG) {
			String molfile = (new MolfileCreator(testMolecule)).getMolfile();
			try {
				PrintWriter writer = new PrintWriter("testCopied.mol");
				writer.println(molfile);
				writer.close();
			} catch (FileNotFoundException e) {
				e.printStackTrace();
			}
		}
		MolFileAtomEntry[] molfileHydrogens = new MolFileAtomEntry[2];
		int finalID = currentAtom.getFinalID();
		int stackPointer;
		stackPointer = 0;
		// get the neighbouring atom entities
		for (int i = 0; i < currentAtom.getAllNeighbours(); i++) {
			int iMolfileID = currentAtom.getNeighbour(i);
			if (this.atomEntries.get(iMolfileID).getAtomicNo() == 1) {
				molfileHydrogens[stackPointer++] = this.atomEntries.get(iMolfileID);
			}
		}
		// get hydrogen ID's from enhanced molecule
		stackPointer = 0;
		int[] enhancedHydrogenIDs = new int[2];
		for (int i = 0; i < this.enhancedMolecule.getAllConnAtoms(finalID); i++) {
			if (this.enhancedMolecule.getAtomicNo(this.enhancedMolecule.getConnAtom(finalID, i)) == 1) {
				enhancedHydrogenIDs[stackPointer++] = this.enhancedMolecule.getConnAtom(finalID, i);
			}
		}
		for (int i = 0; i < this.atomEntries.size(); i++) {
			MolFileAtomEntry entry = this.atomEntries.get(i);
			if (entry.getAtomicNo() != 1) {
				int cid = entry.getFinalID();
				testMolecule.setAtomX(cid, entry.getX());
				testMolecule.setAtomY(cid, entry.getY());
				testMolecule.setAtomZ(cid, entry.getZ());
			}
		}
		// replace the first atom
		int avlAtomicNo = EPFLUtils.getReplacementAtom(this.enhancedMolecule);
		int iNewAtom = testMolecule.addAtom(molfileHydrogens[0].getX(),
				molfileHydrogens[0].getY(), molfileHydrogens[0].getZ());
		testMolecule.setAtomicNo(iNewAtom, avlAtomicNo);
		testMolecule.addBond(finalID, iNewAtom, Molecule.cBondTypeSingle);
		iNewAtom = testMolecule.addAtom(molfileHydrogens[1].getX(),
				molfileHydrogens[1].getY(), molfileHydrogens[1].getZ());
		testMolecule.setAtomicNo(iNewAtom, 1);
		testMolecule.addBond(finalID, iNewAtom, Molecule.cBondTypeSingle);
		if (DEBUG) {
			String molfile = (new MolfileCreator(testMolecule)).getMolfile();
			try {
				PrintWriter writer = new PrintWriter("testMolecule.mol");
				writer.println(molfile);
				writer.close();
			} catch (FileNotFoundException e) {
				e.printStackTrace();
			}

		}
		Canonizer canonizer = new Canonizer(testMolecule);
		String idcode = canonizer.getIDCode();
		String coordinates = canonizer.getEncodedCoordinates(true);
		int[] finalIndexes1 = canonizer.getGraphIndexes();
		int targetID = finalIndexes1[finalID];
		IDCodeParser parser = new IDCodeParser();
		testMolecule = parser.getCompactMolecule(idcode, coordinates);
		int iNeighbour = -1;
		for (int i = 0; i < testMolecule.getConnAtoms(targetID); i++) {
			if (testMolecule.getAtomicNo(testMolecule.getConnAtom(targetID, i)) != avlAtomicNo) {
				iNeighbour = testMolecule.getConnAtom(targetID, i);
				break;
			}
		}
		if (iNeighbour != -1) {
			boolean canAssign = false;
			boolean swapOrder = false;
			
			if (DEBUG) System.out.println(new MolfileCreator(testMolecule).getMolfile());
			
			
			for (int iBond = 0; iBond < testMolecule.getAllBonds(); iBond++) {
				
				if ((testMolecule.getBondAtom(0, iBond) == targetID && testMolecule.getBondAtom(1, iBond) == iNeighbour)
						|| (testMolecule.getBondAtom(1, iBond) == targetID && testMolecule.getBondAtom(0, iBond) == iNeighbour)) {
					if (testMolecule.getBondParity(iBond) == Molecule.cBondCIPParityEorP) {
						if (DEBUG) {
							System.out.println("First Hydrogen pro E between atoms: "+testMolecule.getBondAtom(0, iBond)+" and "+testMolecule.getBondAtom(1, iBond));
						}
						canAssign = true;
						if (this.stereoInfo[enhancedHydrogenIDs[0]] == StereoInfo.PRO_Z)
							swapOrder = true;
						break;
					} else if (testMolecule.getBondParity(iBond) == Molecule.cBondCIPParityZorM) {
						if (DEBUG) System.out.println("First Hydrogen pro Z");
						canAssign = true;
						if (this.stereoInfo[enhancedHydrogenIDs[0]] == StereoInfo.PRO_E)
							swapOrder = true;
						break;

					}
				}
			}
			if (canAssign) {
				if (swapOrder) {
					molfileHydrogens[0].setFinalID(enhancedHydrogenIDs[1]);
					molfileHydrogens[1].setFinalID(enhancedHydrogenIDs[0]);
				} else {
					molfileHydrogens[0].setFinalID(enhancedHydrogenIDs[0]);
					molfileHydrogens[1].setFinalID(enhancedHydrogenIDs[1]);
				}
			} else {
				System.out.println("Problematic assignment");
			}
		} else {
			System.out.println("Problematic assignment");
		}
	}

	private void handleEquivalentProtons(MolFileAtomEntry currentAtom) {
		int enhancedID = currentAtom.getFinalID();
		if (DEBUG) {
			System.out.println("nHydI="
					+ this.initialMolecule.getAllHydrogens(currentAtom
							.getActelionSortedID()));
			System.out.println("nHydE="
					+ this.enhancedMolecule.getAllHydrogens(currentAtom
							.getFinalID()));
			System.out.println("atomicNoI="
					+ this.initialMolecule.getAtomicNo(currentAtom
							.getActelionSortedID()));
			System.out.println("atomicNoE="
					+ this.enhancedMolecule.getAtomicNo(currentAtom
							.getFinalID()));
		}
		int nHydrogens = this.enhancedMolecule.getAllHydrogens(enhancedID);
		int stackPointer;
		int[] enhancedHydrogens = new int[nHydrogens];
		int[] molfileHydrogens = new int[nHydrogens];
		// enhanced
		stackPointer = 0;
		for (int i = 0; i < this.enhancedMolecule.getAllConnAtoms(enhancedID); i++) {
			int id = this.enhancedMolecule.getConnAtom(enhancedID, i);
			if (this.enhancedMolecule.getAtomicNo(id) == 1)
				enhancedHydrogens[stackPointer++] = id;
		}
		if (stackPointer != nHydrogens) {
			System.out.println("not enough hydrogens in enhanced molecule");
			System.exit(-1);
		}
		// molfile
		stackPointer = 0;
		for (int i = 0; i < currentAtom.getAllNeighbours(); i++) {
			int molNeighbourId = currentAtom.getNeighbour(i);
			if (this.atomEntries.get(molNeighbourId).getAtomicNo() == 1)
				molfileHydrogens[stackPointer++] = molNeighbourId;
		}
		if (stackPointer != nHydrogens) {
			System.out.println("not enough hydrogens in initial molecule");
			System.exit(-1);
		}
		double[][] distance = new double[nHydrogens][nHydrogens];
		for (int iIni = 0; iIni < nHydrogens; iIni++) {
			int idIni = molfileHydrogens[iIni];
			double x1 = this.atomEntries.get(idIni).getX();
			double y1 = this.atomEntries.get(idIni).getY();
			double z1 = this.atomEntries.get(idIni).getZ();
			for (int iEnh = 0; iEnh < nHydrogens; iEnh++) {
				int idEnh = enhancedHydrogens[iEnh];
				double x2 = this.enhancedMolecule.getAtomX(idEnh);
				double y2 = this.enhancedMolecule.getAtomY(idEnh);
				double z2 = this.enhancedMolecule.getAtomZ(idEnh);
				distance[iIni][iEnh] = Math.pow(x1 - x2, 2)
						+ Math.pow(y1 - y2, 2) + Math.pow(z1 - z2, 2);
			}
		}
		int[][] assignement = HungarianAlgorithm.hgAlgorithm(distance, "min");
		if (assignement.length != nHydrogens) {
			System.out.println("no assignemnt");
			System.exit(-1);
		}
		for (int i = 0; i < nHydrogens; i++) {
			int idIni = molfileHydrogens[assignement[i][0]];
			int idEnh = enhancedHydrogens[assignement[i][1]];
			this.atomEntries.get(idIni).setFinalID(idEnh);
		}

	}

	private void generateHelperMolecules() {
		StereoMolecule canInMolecule = new StereoMolecule();
		this.initialMolecule.copyMolecule(canInMolecule);
		Canonizer canonizer = new Canonizer(canInMolecule);
		String idcode = canonizer.getIDCode();
		String coordinates = canonizer.getEncodedCoordinates(true);
		IDCodeParser parser = new IDCodeParser();
		this.compactMolecule = parser.getCompactMolecule(idcode, coordinates);
		int graphIndexes[] = canonizer.getGraphIndexes();
		for (int ii = 0; ii < graphIndexes.length; ii++) {
			for (int iAtomEntry = 0; iAtomEntry < this.atomEntries.size(); iAtomEntry++)  {
				if (this.atomEntries.get(iAtomEntry).getActelionSortedID() == ii)
					this.atomEntries.get(iAtomEntry).setFinalID(graphIndexes[ii]);
			}
//			if (this.indeces[ii] < this.compactMolecule.getAllAtoms())
//				this.atomEntries.get(ii).setFinalID(
//						graphIndexes[this.indeces[ii]]);
		}
		this.compactMolecule.ensureHelperArrays(2);
		this.enhancedMolecule = parser.getCompactMolecule(idcode, coordinates);
		HydrogenHandler.addImplicitHydrogens(this.enhancedMolecule);
		this.enhancedMolecule.ensureHelperArrays(2);

		this.stereoInfo = EPFLUtils.determineNonEquivalentProtons(
				this.enhancedMolecule, this.compactMolecule);
		this.symRanks = EPFLUtils
				.getProtonSymmRanksBySubstitution(this.enhancedMolecule);
		this.enhancedMolecule.ensureHelperArrays(2);
	}

	/**
	 * Thomas Sander user a shuffle algorithm to bring all hydrogens to the end
	 * of the molecule the first found hydrogen is swapped with the last found
	 * heavy atom.
	 */
	private void determineInitialIndexes() {
		int nAtoms = atomEntries.size();
		this.indeces = new int[nAtoms];
		for (int i = 0; i < nAtoms; i++)
			this.indeces[i] = i;
		int tmp;
		int lower = 0;
		int upper = nAtoms - 1;
		while (lower < upper) {
			while (this.atomEntries.get(lower).getAtomicNo() != 1)
				lower++;
			while (this.atomEntries.get(upper).getAtomicNo() == 1)
				upper--;
			if (upper < 0)
				break;
			if (lower > nAtoms - 1)
				break;
			if (lower < upper) {
				tmp = indeces[upper];
				indeces[upper] = indeces[lower];
				indeces[lower] = tmp;
				lower++;
				upper--;
			}

		}
		for (int i = 0; i < nAtoms; i++) {
			this.atomEntries.get(i).setActelionSortedID(this.indeces[i]);
			if (DEBUG)
				System.out.println(i + ": "
						+ this.atomEntries.get(i).getActelionSortedID() + ","
						+ indeces[i]);
		}
	}

	private void readMolFile() {
		this.atomEntries = new Vector<MolFileAtomEntry>();
		try {
			BufferedReader reader = new BufferedReader(new FileReader(
					this.inputMolfile));
			for (int i = 0; i < 3; i++)
				reader.readLine();
			String countsLine = reader.readLine();
			int nAtoms = Integer.parseInt(countsLine.substring(0, 3).trim());
			int nBonds = Integer.parseInt(countsLine.substring(3, 6).trim());
			for (int i = 0; i < nAtoms; i++) {
				String currentLine = reader.readLine();
				float x = Float.parseFloat(currentLine.substring(00, 10).trim());
				float y = Float.parseFloat(currentLine.substring(10, 20).trim());
				float z = Float.parseFloat(currentLine.substring(20, 30).trim());
				int atomicNo = Molecule.getAtomicNoFromLabel(currentLine
						.substring(31, 34).trim());
				MolFileAtomEntry entry = new MolFileAtomEntry();
				entry.setMolFileID(i);
				entry.setAtomicNo(atomicNo);
				entry.setX(x);
				// this is also done in the actelion code
				entry.setY(-y);
				entry.setZ(-z);
				atomEntries.add(entry);
			}
			for (int iBond = 0; iBond < nBonds; iBond++) {
				String currentLine = reader.readLine();
				int iAtom1 = Integer.parseInt(currentLine.substring(0, 3)
						.trim()) - 1;
				int iAtom2 = Integer.parseInt(currentLine.substring(3, 6)
						.trim()) - 1;
				this.atomEntries.get(iAtom1).addNeighbour(iAtom2);
				this.atomEntries.get(iAtom2).addNeighbour(iAtom1);
			}
		} catch (FileNotFoundException e) {
			e.printStackTrace();
		} catch (IOException e) {
			e.printStackTrace();
		}
	}

	/**
	 * @param args
	 */
	public static void main(String[] args) {
		File molFile = null;
		if (args.length == 1) {
			molFile = new File(args[0]);
		}
		if (molFile == null || !molFile.exists()) {
			System.out.println("no valid molfile given");
			System.exit(-1);
		}
		IDRemapper remapper = new IDRemapper(molFile);
		remapper.remap();
	}

	private static Vector<MolFileAtomEntry> parse(File molFile) {
		Vector<MolFileAtomEntry> atomEntries = new Vector<MolFileAtomEntry>();
		try {
			BufferedReader reader = new BufferedReader(new FileReader(molFile));
			for (int i = 0; i < 3; i++)
				reader.readLine();
			String countsLine = reader.readLine();
			int nAtoms = Integer.parseInt(countsLine.substring(0, 3).trim());
			for (int i = 0; i < nAtoms; i++) {
				String currentLine = reader.readLine();
				float x = Float.parseFloat(currentLine.substring(00, 10).trim());
				float y = Float.parseFloat(currentLine.substring(10, 20).trim());
				float z = Float.parseFloat(currentLine.substring(20, 30).trim());
				int atomicNo = Molecule.getAtomicNoFromLabel(currentLine
						.substring(31, 34).trim());
				MolFileAtomEntry entry = new MolFileAtomEntry();
				entry.setMolFileID(i);
				entry.setAtomicNo(atomicNo);
				entry.setX(x);
				// this is also done in the actelion code
				entry.setY(-y);
				entry.setZ(-z);
				atomEntries.add(entry);
			}
		} catch (FileNotFoundException e) {
			e.printStackTrace();
		} catch (IOException e) {
			e.printStackTrace();
		}
		return atomEntries;
	}

	
}

/**
 * A class representing an atom entry in a molfile coming from moloc
 * 
 * 
 * @author engeler
 * 
 */
class MolFileAtomEntry {
	/** The id as given in the input molfile */
	private int molFileID = -1;
	/** The atomic number */
	private int atomicNo = -1;
	/** The final ID corresponting to the ID which is equal to the one from Nemo */
	private int finalID = -1;
	/** The id after the sort algorithm of actelion */
	private int actelionSortedID = -1;
	/** the symmetry rank */
	private int symmetryRank = -1;
	private float x = Float.NaN;
	private float y = Float.NaN;
	private float z = Float.NaN;
	private Vector<Integer> neighbours = new Vector<Integer>();

	public MolFileAtomEntry() {

	}

	public void addNeighbour(int id) {
		this.neighbours.add(id);
	}

	public int getNeighbour(int index) {
		return this.neighbours.get(index);
	}

	public int getAllNeighbours() {
		return this.neighbours.size();
	}

	public int getMolFileID() {
		return molFileID;
	}

	public void setMolFileID(int molFileID) {
		this.molFileID = molFileID;
	}

	public int getAtomicNo() {
		return atomicNo;
	}

	public void setAtomicNo(int atomicNo) {
		this.atomicNo = atomicNo;
	}

	public int getFinalID() {
		return finalID;
	}

	public void setFinalID(int finalID) {
		this.finalID = finalID;
	}

	public int getSymmetryRank() {
		return symmetryRank;
	}

	public void setSymmetryRank(int symmetryRank) {
		this.symmetryRank = symmetryRank;
	}

	public float getX() {
		return x;
	}

	public void setX(float x) {
		this.x = x;
	}

	public float getY() {
		return y;
	}

	public void setY(float y) {
		this.y = y;
	}

	public float getZ() {
		return z;
	}

	public void setZ(float z) {
		this.z = z;
	}

	public int findClosestAtom(StereoMolecule mol) {
		int closest = -1;
		double minDist = Double.MAX_VALUE;
		for (int iAtom = 0; iAtom < mol.getAllAtoms(); iAtom++) {
			if (mol.getAtomicNo(iAtom) == this.atomicNo) {
				double dist = Math.sqrt(Math.pow(mol.getAtomX(iAtom) - x, 2)
						+ Math.pow(mol.getAtomY(iAtom) - y, 2)
						+ Math.pow(mol.getAtomZ(iAtom) - z, 2));
				if (dist < minDist) {
					closest = iAtom;
					minDist = dist;
				}
			}
		}
		return closest;
	}

	public int getActelionSortedID() {
		return actelionSortedID;
	}

	public void setActelionSortedID(int actelionID) {
		this.actelionSortedID = actelionID;
	}

	public double getDistance(MolFileAtomEntry entry) {
		double dx = entry.getX() - this.x;
		double dy = entry.getY() - this.y;
		double dz = entry.getZ() - this.z;
		return Math.sqrt(Math.pow(dx, 2) + Math.pow(dy, 2) + Math.pow(dz, 2));
	}

}
